# 充电分析系统模块实现文档

## 1. 项目结构

```
charge/
├── backend/                          # Python后端
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py                  # FastAPI应用入口
│   │   ├── config.py                # 配置管理
│   │   ├── database.py              # 数据库连接
│   │   │
│   │   ├── api/                     # API路由
│   │   │   ├── __init__.py
│   │   │   ├── auth.py              # 认证API
│   │   │   ├── analysis.py          # 充电分析API
│   │   │   ├── training.py          # 训练管理API
│   │   │   ├── rag.py               # RAG管理API
│   │   │   └── logs.py              # 日志管理API
│   │   │
│   │   ├── models/                  # 数据模型
│   │   │   ├── __init__.py
│   │   │   ├── user.py              # 用户模型
│   │   │   ├── task.py              # 任务模型
│   │   │   ├── dataset.py           # 数据集模型
│   │   │   ├── training.py          # 训练模型
│   │   │   └── rag.py               # RAG知识模型
│   │   │
│   │   ├── schemas/                 # Pydantic模式
│   │   │   ├── __init__.py
│   │   │   ├── auth.py
│   │   │   ├── analysis.py
│   │   │   ├── training.py
│   │   │   └── rag.py
│   │   │
│   │   ├── services/                # 业务服务层
│   │   │   ├── __init__.py
│   │   │   ├── auth_service.py     # 认证服务
│   │   │   ├── file_service.py     # 文件服务
│   │   │   ├── training_service.py # 训练服务
│   │   │   └── log_service.py      # 日志服务
│   │   │
│   │   ├── agents/                  # LangGraph Agents
│   │   │   ├── __init__.py
│   │   │   ├── base_agent.py       # Agent基类
│   │   │   ├── charging_agent.py   # 充电分析Agent
│   │   │   ├── thermal_agent.py    # 热管理Agent（预留）
│   │   │   ├── energy_agent.py     # 能量Agent（预留）
│   │   │   ├── driving_agent.py    # 行驶Agent（预留）
│   │   │   └── coordinator.py      # Agent协调器
│   │   │
│   │   ├── tools/                   # Agent工具
│   │   │   ├── __init__.py
│   │   │   ├── can_parser.py       # CAN报文解析工具
│   │   │   ├── rag_tool.py         # RAG检索工具
│   │   │   ├── flow_model.py       # 1.5B流程控制模型
│   │   │   ├── llm_tool.py         # LLM调用工具
│   │   │   └── report_generator.py # 报告生成工具
│   │   │
│   │   ├── rag/                     # RAG系统
│   │   │   ├── __init__.py
│   │   │   ├── vector_store.py     # ChromaDB向量存储
│   │   │   ├── embedding.py        # BGE嵌入模型
│   │   │   └── retriever.py        # 检索器
│   │   │
│   │   ├── training/                # 训练系统
│   │   │   ├── __init__.py
│   │   │   ├── dataset_manager.py  # 数据集管理
│   │   │   ├── trainer.py          # 训练器
│   │   │   ├── model_manager.py    # 模型版本管理
│   │   │   └── evaluator.py        # 评估器
│   │   │
│   │   ├── logging/                 # 日志系统
│   │   │   ├── __init__.py
│   │   │   ├── logger.py           # 日志配置
│   │   │   ├── handler.py          # 日志处理器
│   │   │   └── query.py            # 日志查询
│   │   │
│   │   └── utils/                   # 工具函数
│   │       ├── __init__.py
│   │       ├── security.py         # 安全工具（JWT、密码）
│   │       ├── storage.py          # 存储工具（MinIO）
│   │       └── cache.py            # 缓存工具（Redis）
│   │
│   ├── tests/                       # 测试
│   ├── alembic/                     # 数据库迁移
│   ├── requirements.txt             # Python依赖
│   ├── Dockerfile                   # Docker镜像
│   └── docker-compose.yml           # Docker编排
│
├── frontend/                        # React Native前端
│   ├── src/
│   │   ├── App.tsx                  # 应用入口
│   │   ├── navigation/             # 导航配置
│   │   │   ├── AppNavigator.tsx
│   │   │   └── AuthNavigator.tsx
│   │   │
│   │   ├── screens/                # 页面组件
│   │   │   ├── HomeScreen.tsx      # 首页
│   │   │   ├── ChatScreen.tsx      # 对话
│   │   │   ├── AnalysisScreen.tsx  # 充电分析
│   │   │   ├── RAGScreen.tsx       # RAG管理
│   │   │   ├── TrainingScreen.tsx  # 训练管理
│   │   │   └── LogsScreen.tsx      # 日志管理
│   │   │
│   │   ├── components/             # 通用组件
│   │   │   ├── Sidebar.tsx         # 侧边栏
│   │   │   ├── Chart.tsx           # 图表组件
│   │   │   ├── FileUpload.tsx      # 文件上传
│   │   │   └── ProgressBar.tsx     # 进度条
│   │   │
│   │   ├── services/               # 服务层
│   │   │   ├── api.ts              # API客户端
│   │   │   ├── auth.ts             # 认证服务
│   │   │   └── storage.ts          # 本地存储
│   │   │
│   │   ├── store/                  # 状态管理
│   │   │   ├── authSlice.ts       # 认证状态
│   │   │   ├── analysisSlice.ts   # 分析状态
│   │   │   └── store.ts           # Store配置
│   │   │
│   │   └── utils/                  # 工具函数
│   │       ├── constants.ts
│   │       └── helpers.ts
│   │
│   ├── package.json
│   └── tsconfig.json
│
└── docs/                            # 文档
    ├── 01-系统架构文档.md
    ├── 02-系统设计文档.md
    └── 03-模块实现文档.md
```

## 2. 核心模块实现

### 2.1 认证模块

#### 2.1.1 用户模型 (app/models/user.py)
```python
from sqlalchemy import Column, String, Boolean, DateTime, Enum
from sqlalchemy.dialects.postgresql import UUID
import uuid
from app.database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    role = Column(String(20), nullable=False, default='user')
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

#### 2.1.2 认证服务 (app/services/auth_service.py)
- JWT Token生成和验证
- 密码加密（bcrypt）
- 用户注册/登录逻辑
- 权限检查装饰器

### 2.2 充电分析Agent模块

#### 2.2.1 Agent基类 (app/agents/base_agent.py)
```python
from abc import ABC, abstractmethod
from typing import Dict, Any

class BaseAgent(ABC):
    """Agent基类，所有Agent必须实现"""
    
    @abstractmethod
    async def analyze(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """执行分析任务"""
        pass
    
    @abstractmethod
    def get_capabilities(self) -> list[str]:
        """返回Agent能力列表"""
        pass
    
    @abstractmethod
    def get_name(self) -> str:
        """返回Agent名称"""
        pass
```

#### 2.2.2 充电分析Agent (app/agents/charging_agent.py)
使用LangGraph实现状态机：

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict, List

class ChargingAgentState(TypedDict):
    task_id: str
    file_path: str
    dataframe: pd.DataFrame
    key_signals: List[str]
    problem_direction: str
    rag_knowledge: List[Dict]
    refined_signals: List[str]
    iteration_count: int
    problem_summary: str
    report: str
    status: str
    error: str

def create_charging_agent():
    workflow = StateGraph(ChargingAgentState)
    
    # 添加节点
    workflow.add_node("parse_message", parse_message_tool)
    workflow.add_node("flow_model_direction", flow_model_direction)
    workflow.add_node("rag_retrieval", rag_retrieval_tool)
    workflow.add_node("flow_model_refine", flow_model_refine)
    workflow.add_node("llm_summary", llm_summary_tool)
    workflow.add_node("generate_report", report_generator_tool)
    
    # 添加边
    workflow.set_entry_point("parse_message")
    workflow.add_edge("parse_message", "flow_model_direction")
    workflow.add_edge("flow_model_direction", "rag_retrieval")
    workflow.add_edge("rag_retrieval", "flow_model_refine")
    workflow.add_conditional_edges(
        "flow_model_refine",
        should_continue_refinement,
        {
            "continue": "flow_model_refine",
            "complete": "llm_summary"
        }
    )
    workflow.add_edge("llm_summary", "generate_report")
    workflow.add_edge("generate_report", END)
    
    return workflow.compile()
```

#### 2.2.3 工具实现

**CAN报文解析工具 (app/tools/can_parser.py)**
- 继承原有CanParse类
- 解析BLF文件为DataFrame
- 信号过滤和预处理

**流程控制模型工具 (app/tools/flow_model.py)**
```python
class FlowModelTool:
    def __init__(self, model_path: str):
        self.model = load_model(model_path)  # 1.5B模型
    
    def determine_direction(self, df: pd.DataFrame) -> Dict:
        """确定问题大方向"""
        features = self.extract_features(df)
        result = self.model.predict(features)
        return {
            "key_signals": result["signals"],
            "problem_direction": result["direction"]
        }
    
    def refine_problem(self, df: pd.DataFrame, rag_knowledge: List[Dict]) -> Dict:
        """细化问题"""
        features = self.extract_features(df)
        context = self.prepare_context(rag_knowledge)
        result = self.model.predict_with_context(features, context)
        return {
            "refined_signals": result["signals"],
            "problem_type": result["problem"]
        }
```

**RAG检索工具 (app/tools/rag_tool.py)**
```python
class RAGTool:
    def __init__(self, vector_store: VectorStore, retriever: Retriever):
        self.vector_store = vector_store
        self.retriever = retriever
    
    async def retrieve(self, query: str, top_k: int = 5) -> List[Dict]:
        """检索相关知识"""
        results = await self.retriever.retrieve(query, top_k)
        return results
    
    async def get_refined_signals(self, problem_direction: str) -> List[str]:
        """获取细化问题的关键信号"""
        query = f"针对{problem_direction}问题的关键信号"
        results = await self.retrieve(query, top_k=3)
        return [r["signals"] for r in results]
```

**LLM调用工具 (app/tools/llm_tool.py)**
```python
from openai import AsyncOpenAI

class LLMTool:
    def __init__(self, api_key: str, base_url: str):
        self.client = AsyncOpenAI(api_key=api_key, base_url=base_url)
    
    async def summarize(self, context: Dict) -> str:
        """使用LLM总结问题"""
        prompt = self.build_prompt(context)
        response = await self.client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            stream=True
        )
        return response
```

**报告生成工具 (app/tools/report_generator.py)**
```python
class ReportGenerator:
    def generate(self, summary: str, data: Dict) -> str:
        """生成Markdown格式报告"""
        template = self.load_template()
        report = template.render(
            summary=summary,
            key_signals=data["key_signals"],
            diagnosis=data["diagnosis"],
            recommendations=data["recommendations"]
        )
        return report
```

### 2.3 RAG系统模块

#### 2.3.1 向量存储 (app/rag/vector_store.py)
```python
import chromadb
from chromadb.config import Settings

class VectorStore:
    def __init__(self, persist_directory: str):
        self.client = chromadb.PersistentClient(
            path=persist_directory,
            settings=Settings(anonymized_telemetry=False)
        )
        self.collection = self.client.get_or_create_collection(
            name="charging_knowledge",
            metadata={"hnsw:space": "cosine"}
        )
    
    def add_documents(self, documents: List[str], metadatas: List[Dict], ids: List[str]):
        """添加文档到向量库"""
        self.collection.add(
            documents=documents,
            metadatas=metadatas,
            ids=ids
        )
    
    def query(self, query_embeddings: List[List[float]], n_results: int = 5):
        """查询相似文档"""
        return self.collection.query(
            query_embeddings=query_embeddings,
            n_results=n_results
        )
```

#### 2.3.2 嵌入模型 (app/rag/embedding.py)
```python
from sentence_transformers import SentenceTransformer

class EmbeddingModel:
    def __init__(self, model_name: str = "BAAI/bge-base-zh-v1.5"):
        self.model = SentenceTransformer(model_name)
    
    def encode(self, texts: List[str]) -> np.ndarray:
        """生成文本嵌入"""
        return self.model.encode(texts, normalize_embeddings=True)
```

#### 2.3.3 检索器 (app/rag/retriever.py)
```python
class Retriever:
    def __init__(self, vector_store: VectorStore, embedding_model: EmbeddingModel):
        self.vector_store = vector_store
        self.embedding_model = embedding_model
    
    async def retrieve(self, query: str, top_k: int = 5) -> List[Dict]:
        """检索相关文档"""
        # 生成查询嵌入
        query_embedding = self.embedding_model.encode([query])[0].tolist()
        
        # 向量检索
        results = self.vector_store.query(
            query_embeddings=[query_embedding],
            n_results=top_k
        )
        
        # 格式化结果
        return [
            {
                "content": doc,
                "metadata": meta,
                "score": score
            }
            for doc, meta, score in zip(
                results["documents"][0],
                results["metadatas"][0],
                results["distances"][0]
            )
        ]
```

### 2.4 训练系统模块

#### 2.4.1 数据集管理 (app/training/dataset_manager.py)
```python
class DatasetManager:
    def validate_dataset(self, file_path: str, dataset_type: str) -> bool:
        """验证数据集格式"""
        if dataset_type == "normal":
            return self._validate_normal_dataset(file_path)
        elif dataset_type == "chain_of_thought":
            return self._validate_cot_dataset(file_path)
    
    def load_dataset(self, dataset_id: str) -> Dataset:
        """加载数据集"""
        pass
    
    def preprocess(self, dataset: Dataset) -> Dataset:
        """数据预处理"""
        pass
```

#### 2.4.2 训练器 (app/training/trainer.py)
```python
import torch
from transformers import Trainer, TrainingArguments

class ModelTrainer:
    def __init__(self, model_config: Dict):
        self.model = self._load_model(model_config)
        self.tokenizer = self._load_tokenizer(model_config)
    
    def train(self, dataset: Dataset, hyperparameters: Dict) -> TrainingResult:
        """执行训练"""
        training_args = TrainingArguments(
            output_dir="./results",
            num_train_epochs=hyperparameters["epochs"],
            per_device_train_batch_size=hyperparameters["batch_size"],
            learning_rate=hyperparameters["learning_rate"],
            logging_dir="./logs",
            logging_steps=10,
            save_steps=100,
            evaluation_strategy="epoch"
        )
        
        trainer = Trainer(
            model=self.model,
            args=training_args,
            train_dataset=dataset.train,
            eval_dataset=dataset.val,
            callbacks=[ProgressCallback(), LossCallback()]
        )
        
        trainer.train()
        return TrainingResult(
            model_path=trainer.save_model(),
            metrics=trainer.evaluate()
        )
```

#### 2.4.3 模型版本管理 (app/training/model_manager.py)
```python
class ModelManager:
    def create_version(self, training_task_id: str, model_path: str) -> ModelVersion:
        """创建模型版本"""
        version = self._generate_version()
        model_version = ModelVersion(
            training_task_id=training_task_id,
            version=version,
            model_path=model_path
        )
        db.session.add(model_version)
        db.session.commit()
        return model_version
    
    def activate_version(self, version_id: str) -> bool:
        """激活模型版本"""
        # 停用当前激活版本
        ModelVersion.query.filter_by(is_active=True).update({"is_active": False})
        
        # 激活新版本
        model_version = ModelVersion.query.get(version_id)
        model_version.is_active = True
        model_version.activated_at = datetime.utcnow()
        db.session.commit()
        return True
    
    def rollback_version(self, version_id: str) -> bool:
        """回滚到指定版本"""
        return self.activate_version(version_id)
```

### 2.5 日志系统模块

#### 2.5.1 日志配置 (app/logging/logger.py)
```python
import structlog
from structlog.stdlib import LoggerFactory

def configure_logging():
    structlog.configure(
        processors=[
            structlog.stdlib.filter_by_level,
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.UnicodeDecoder(),
            structlog.processors.JSONRenderer()
        ],
        context_class=dict,
        logger_factory=LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True,
    )

def get_logger(service: str):
    return structlog.get_logger(service)
```

#### 2.5.2 日志处理器 (app/logging/handler.py)
```python
class DatabaseLogHandler:
    """将日志写入数据库"""
    
    def emit(self, record):
        log_entry = Log(
            timestamp=record.timestamp,
            level=record.level,
            service=record.service,
            user_id=record.user_id,
            task_id=record.task_id,
            message=record.message,
            metadata=record.metadata
        )
        db.session.add(log_entry)
        db.session.commit()
```

## 3. API实现

### 3.1 FastAPI应用入口 (app/main.py)
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api import auth, analysis, training, rag, logs
from app.logging.logger import configure_logging

configure_logging()
app = FastAPI(title="充电分析系统API")

# CORS配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册路由
app.include_router(auth.router, prefix="/api/v1/auth", tags=["认证"])
app.include_router(analysis.router, prefix="/api/v1/analysis", tags=["充电分析"])
app.include_router(training.router, prefix="/api/v1/training", tags=["训练管理"])
app.include_router(rag.router, prefix="/api/v1/rag", tags=["RAG管理"])
app.include_router(logs.router, prefix="/api/v1/logs", tags=["日志管理"])
```

### 3.2 认证API (app/api/auth.py)
```python
from fastapi import APIRouter, Depends, HTTPException
from app.schemas.auth import RegisterRequest, LoginRequest, TokenResponse
from app.services.auth_service import AuthService

router = APIRouter()

@router.post("/register", response_model=TokenResponse)
async def register(request: RegisterRequest):
    """用户注册"""
    service = AuthService()
    result = await service.register(
        username=request.username,
        email=request.email,
        password=request.password
    )
    return result

@router.post("/login", response_model=TokenResponse)
async def login(request: LoginRequest):
    """用户登录"""
    service = AuthService()
    result = await service.login(
        username=request.username,
        password=request.password
    )
    if not result:
        raise HTTPException(status_code=401, detail="用户名或密码错误")
    return result
```

## 4. 前端实现

### 4.1 导航配置 (src/navigation/AppNavigator.tsx)
```typescript
import { createDrawerNavigator } from '@react-navigation/drawer';
import HomeScreen from '../screens/HomeScreen';
import ChatScreen from '../screens/ChatScreen';
import AnalysisScreen from '../screens/AnalysisScreen';
import RAGScreen from '../screens/RAGScreen';
import TrainingScreen from '../screens/TrainingScreen';
import LogsScreen from '../screens/LogsScreen';

const Drawer = createDrawerNavigator();

export default function AppNavigator() {
  const { user } = useAuth();
  const isAdmin = user?.role === 'admin';

  return (
    <Drawer.Navigator>
      <Drawer.Screen name="首页" component={HomeScreen} />
      <Drawer.Screen name="对话" component={ChatScreen} />
      <Drawer.Screen name="充电分析" component={AnalysisScreen} />
      {isAdmin && (
        <>
          <Drawer.Screen name="RAG管理" component={RAGScreen} />
          <Drawer.Screen name="训练管理" component={TrainingScreen} />
          <Drawer.Screen name="日志管理" component={LogsScreen} />
        </>
      )}
    </Drawer.Navigator>
  );
}
```

### 4.2 充电分析页面 (src/screens/AnalysisScreen.tsx)
```typescript
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import FileUpload from '../components/FileUpload';
import Chart from '../components/Chart';
import ProgressBar from '../components/ProgressBar';
import { useAnalysis } from '../hooks/useAnalysis';

export default function AnalysisScreen() {
  const [file, setFile] = useState<File | null>(null);
  const { startAnalysis, progress, result, thinking } = useAnalysis();

  return (
    <View style={styles.container}>
      <FileUpload onFileSelected={setFile} />
      {file && (
        <>
          <ProgressBar progress={progress} />
          <Chart data={result?.data} />
          {thinking && <ThinkingView content={thinking} />}
          {result && <ResultView result={result} />}
        </>
      )}
    </View>
  );
}
```

## 5. 部署配置

### 5.1 Docker配置
- `Dockerfile`: 后端服务镜像
- `docker-compose.yml`: 包含所有服务（PostgreSQL、Redis、ChromaDB、MinIO等）

### 5.2 环境变量
- 数据库连接
- Redis配置
- JWT密钥
- LLM API密钥
- 存储配置

## 6. 测试策略

### 6.1 单元测试
- 各服务模块单元测试
- Agent工具测试
- API端点测试

### 6.2 集成测试
- Agent完整流程测试
- 训练流程测试
- 端到端测试

